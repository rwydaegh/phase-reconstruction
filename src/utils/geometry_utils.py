import logging
import numpy as np

logger = logging.getLogger(__name__)

def get_cube_normals(points: np.ndarray, room_size: float) -> tuple[np.ndarray, np.ndarray]:
    """
    Calculates inward-pointing normals for points generated by create_test_pointcloud.
    Assigns normals based on the coordinate with the largest absolute value,
    assuming points lie approximately on the faces of the cube centered at origin.

    Args:
        points: Array of points presumed to be on the cube surface.
        room_size: The size of the cube.

    Returns:
        Tuple[np.ndarray, np.ndarray]: The input points array and their corresponding
                                       inward-pointing normals.
    """
    normals = np.zeros_like(points)
    # half_size = room_size / 2.0 # Not needed for max-coord logic
    abs_points = np.abs(points)
    # Find the index of the coordinate with the maximum absolute value for each point
    max_coord_indices = np.argmax(abs_points, axis=1)

    # Assign normals based on the max coordinate index and the sign of the coordinate
    # Assumes the point generation places points sufficiently close to the faces.
    for i, idx in enumerate(max_coord_indices):
        coord_value = points[i, idx]
        if idx == 0: # Max is X
            normals[i, 0] = 1.0 if coord_value > 0 else -1.0
        elif idx == 1: # Max is Y
            normals[i, 1] = 1.0 if coord_value > 0 else -1.0
        else: # Max is Z
            normals[i, 2] = 1.0 if coord_value > 0 else -1.0

    # Verify that normals were assigned (check non-zero norms)
    # This check should now pass if create_test_pointcloud works as expected
    norm_n = np.linalg.norm(normals, axis=1)
    valid_mask = norm_n > 1e-9
    num_invalid = points.shape[0] - np.sum(valid_mask)
    if num_invalid > 0:
        msg = f"Could not assign a valid normal to {num_invalid} points using max-coord logic (points might be exactly at origin?)."
        try:
            logger.warning(msg)
        except NameError:
            print(f"WARNING: {msg}")
        # Ensure invalid points have zero normal explicitly
        normals[~valid_mask] = 0.0

    # Return all points and the calculated normals
    return points, normals