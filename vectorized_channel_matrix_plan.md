# Mathematical Derivation and Plan for Vectorized Channel Matrix

This document outlines the mathematical steps to derive the channel matrix $\mathbf{H}$ that relates unknown current density coefficients on scattering surfaces to the measured electric field component in a specific direction. This approach uses the far-field approximation of the dyadic Green's function and incorporates the geometry of the scattering surfaces via their normal vectors.

**1. Background: Electric Field from Current Densities**

From Maxwell's equations and the Huygens-Fresnel principle, the electric field $\mathbf{e}(\mathbf{r})$ at a measurement point $\mathbf{r}$ generated by current densities $\mathbf{j}(\mathbf{r}')$ on a surface $S$ can be expressed using the dyadic Green's function $\overline{\overline{\mathbf{G}}}(\mathbf{r}, \mathbf{r}')$:

$$ \mathbf{e}(\mathbf{r}) = -j\omega \mu_0 \int_S \overline{\overline{\mathbf{G}}}(\mathbf{r}, \mathbf{r}') \cdot \mathbf{j}(\mathbf{r}') \, \mathrm{d}S' $$

**2. Far-Field Approximation**

In the far-field ($kR \to \infty$, where $R = |\mathbf{r} - \mathbf{r}'|$ and $k$ is the wavenumber), the Green's tensor simplifies to:

$$ \overline{\overline{\mathbf{G}}}(\mathbf{r},\mathbf{r}') \approx \frac{\exp ( -j k R )}{4\pi R} \left( \mathbf{I} - \hat{\mathbf{R}}\hat{\mathbf{R}}\right) $$

where $\mathbf{R} = \mathbf{r} - \mathbf{r}'$, $R = |\mathbf{R}|$, and $\hat{\mathbf{R}} = \mathbf{R}/R$. The term $(\mathbf{I} - \hat{\mathbf{R}}\hat{\mathbf{R}})$ is a projection operator that projects any vector onto the plane perpendicular to the direction vector $\hat{\mathbf{R}}$.

**3. Discretization using Scattering Clusters**

We approximate the integral by discretizing the surface $S$ into $N_c$ small patches or *scattering clusters*, indexed by $c$. Each cluster is located at $\mathbf{r}_c$. The electric field at a measurement point $\mathbf{r}_i$ (indexed by $i$, $N_m$ total points) is approximated by the sum of contributions from all clusters:

$$ \mathbf{e}(\mathbf{r}_i) \approx \sum_{c=1}^{N_c} \Delta \mathbf{e}_{ic} $$

where $\Delta \mathbf{e}_{ic}$ is the contribution from cluster $c$. Using the far-field approximation for the Green's function between $\mathbf{r}_i$ and $\mathbf{r}_c$:

$$ \Delta \mathbf{e}_{ic} \approx C \frac{\exp ( -j k R_{ic} )}{R_{ic}} \left( \mathbf{I} - \hat{\mathbf{R}}_{ic}\hat{\mathbf{R}}_{ic}\right) \cdot \mathbf{j}(\mathbf{r}_c) $$

Here, $R_{ic} = |\mathbf{r}_i - \mathbf{r}_c|$, $\hat{\mathbf{R}}_{ic} = (\mathbf{r}_i - \mathbf{r}_c)/R_{ic}$, and $C = -j\omega \mu_0 \Delta S_c / (4\pi)$ is a complex constant incorporating the cluster area $\Delta S_c$. We can absorb this constant into the definition of the unknown current coefficients.

**4. Incorporating Surface Normals and Current Basis**

The current density $\mathbf{j}(\mathbf{r}_c)$ on the surface at cluster $c$ must lie in the tangent plane at that point. Let $\mathbf{n}_c$ be the unit normal vector to the surface at $\mathbf{r}_c$. We can define two orthogonal unit basis vectors, $\hat{\mathbf{t}}_{c,1}$ and $\hat{\mathbf{t}}_{c,2}$, that span this tangent plane:
*   $\mathbf{n}_c \cdot \hat{\mathbf{t}}_{c,1} = 0$
*   $\mathbf{n}_c \cdot \hat{\mathbf{t}}_{c,2} = 0$
*   $\hat{\mathbf{t}}_{c,1} \cdot \hat{\mathbf{t}}_{c,2} = 0$

A robust way to define these (assuming $\mathbf{n}_c$ is not parallel to $\hat{\mathbf{z}} = [0, 0, 1]$):
1.  $\mathbf{v}_1 = \hat{\mathbf{z}} \times \mathbf{n}_c$. If $|\mathbf{v}_1| \approx 0$, use $\mathbf{v}_1 = \hat{\mathbf{x}} \times \mathbf{n}_c$.
2.  $\hat{\mathbf{t}}_{c,1} = \mathbf{v}_1 / |\mathbf{v}_1|$
3.  $\hat{\mathbf{t}}_{c,2} = \mathbf{n}_c \times \hat{\mathbf{t}}_{c,1}$

The unknown current density at cluster $c$ can now be expressed as a linear combination of these basis vectors with unknown complex coefficients $x_{c,1}$ and $x_{c,2}$:

$$ \mathbf{j}(\mathbf{r}_c) \propto x_{c,1} \hat{\mathbf{t}}_{c,1} + x_{c,2} \hat{\mathbf{t}}_{c,2} $$

Substituting this into the expression for $\Delta \mathbf{e}_{ic}$ (and absorbing constants into $x$):

$$ \Delta \mathbf{e}_{ic} \approx \frac{\exp ( -j k R_{ic} )}{4\pi R_{ic}} \left[ \left( \mathbf{I} - \hat{\mathbf{R}}_{ic}\hat{\mathbf{R}}_{ic}\right) \cdot \hat{\mathbf{t}}_{c,1} \right] x_{c,1} + \frac{\exp ( -j k R_{ic} )}{4\pi R_{ic}} \left[ \left( \mathbf{I} - \hat{\mathbf{R}}_{ic}\hat{\mathbf{R}}_{ic}\right) \cdot \hat{\mathbf{t}}_{c,2} \right] x_{c,2} $$

**5. Projection onto Measurement Direction**

The measurement probe measures the electric field component along a specific unit direction $\hat{\mathbf{u}}_{\text{meas}}$ (e.g., $\hat{\mathbf{y}} = [0, 1, 0]$ as mentioned in the paper for the longitudinal component). The measured scalar value $y_i$ at point $\mathbf{r}_i$ is:

$$ y_i = \hat{\mathbf{u}}_{\text{meas}} \cdot \mathbf{e}(\mathbf{r}_i) = \sum_{c=1}^{N_c} \hat{\mathbf{u}}_{\text{meas}} \cdot \Delta \mathbf{e}_{ic} $$

$$ y_i \approx \sum_{c=1}^{N_c} \left[ \frac{\exp ( -j k R_{ic} )}{4\pi R_{ic}} \left( \hat{\mathbf{u}}_{\text{meas}} \cdot (\mathbf{I} - \hat{\mathbf{R}}_{ic}\hat{\mathbf{R}}_{ic}) \cdot \hat{\mathbf{t}}_{c,1} \right) \right] x_{c,1} + \left[ \frac{\exp ( -j k R_{ic} )}{4\pi R_{ic}} \left( \hat{\mathbf{u}}_{\text{meas}} \cdot (\mathbf{I} - \hat{\mathbf{R}}_{ic}\hat{\mathbf{R}}_{ic}) \cdot \hat{\mathbf{t}}_{c,2} \right) \right] x_{c,2} $$

**6. Defining the Channel Matrix H**

We want to express the relationship between the vector of measurements $\mathbf{y} \in \mathbb{C}^{N_m}$ and the vector of unknown coefficients $\mathbf{x} \in \mathbb{C}^{2N_c}$ as $\mathbf{y} = \mathbf{H} \mathbf{x}$. The vector $\mathbf{x}$ interleaves the coefficients for the two basis directions for each cluster:

$$ \mathbf{x} = [x_{1,1}, x_{1,2}, x_{2,1}, x_{2,2}, \dots, x_{N_c,1}, x_{N_c,2}]^T $$

The channel matrix $\mathbf{H}$ has dimensions $N_m \times 2N_c$. The element $H_{i,j}$ represents the contribution of the $j$-th unknown coefficient to the $i$-th measurement.

Let the column index $j$ correspond to cluster $c$ and basis vector $k \in \{1, 2\}$. Specifically, $j = 2c-1$ for $k=1$ and $j = 2c$ for $k=2$.

The matrix elements are:

$$ H_{i, 2c-1} = \frac{\exp(-jkR_{ic})}{4\pi R_{ic}} \left( \hat{\mathbf{u}}_{\text{meas}} \cdot \left( \hat{\mathbf{t}}_{c,1} - (\hat{\mathbf{R}}_{ic} \cdot \hat{\mathbf{t}}_{c,1}) \hat{\mathbf{R}}_{ic} \right) \right) $$
$$ H_{i, 2c} = \frac{\exp(-jkR_{ic})}{4\pi R_{ic}} \left( \hat{\mathbf{u}}_{\text{meas}} \cdot \left( \hat{\mathbf{t}}_{c,2} - (\hat{\mathbf{R}}_{ic} \cdot \hat{\mathbf{t}}_{c,2}) \hat{\mathbf{R}}_{ic} \right) \right) $$

**Summary:**

The channel matrix $\mathbf{H}$ relates the $2N_c$ unknown complex current coefficients (two per cluster, aligned with the tangent plane defined by the normal $\mathbf{n}_c$) to the $N_m$ complex electric field measurements projected onto the direction $\hat{\mathbf{u}}_{\text{meas}}$. The calculation involves:
1.  Calculating distances $R_{ic}$ and direction vectors $\hat{\mathbf{R}}_{ic}$ between each measurement point $\mathbf{r}_i$ and cluster point $\mathbf{r}_c$.
2.  Determining the tangent plane basis vectors $\hat{\mathbf{t}}_{c,1}, \hat{\mathbf{t}}_{c,2}$ from the normal $\mathbf{n}_c$ for each cluster.
3.  Calculating the projection term $\hat{\mathbf{u}}_{\text{meas}} \cdot (\mathbf{I} - \hat{\mathbf{R}}_{ic}\hat{\mathbf{R}}_{ic}) \cdot \hat{\mathbf{t}}_{c,k}$ for each $i, c, k$.
4.  Combining these with the scalar Green's function term $\frac{\exp(-jkR_{ic})}{4\pi R_{ic}}$ to form the matrix elements $H_{i, 2c-1}$ and $H_{i, 2c}$.

This formulation provides the basis for a vectorized implementation in Python using NumPy.

---

**Implementation Plan:**

1.  **Modify `src/create_channel_matrix.py`:**
    *   Update the function signature to accept cluster normals (`normals: np.ndarray` shape `(num_points, 3)`) and the measurement direction vector (`measurement_direction: np.ndarray` shape `(3,)`).
    *   Update the docstring to reflect the new inputs and the vectorized nature of the output.
2.  **Implement Tangent Vector Calculation:**
    *   Define a helper function or implement inline logic to calculate the two orthogonal tangent basis vectors ($\hat{\mathbf{t}}_{c,1}, \hat{\mathbf{t}}_{c,2}$) for each normal vector $\mathbf{n}_c$. Handle potential edge cases (e.g., normal parallel to the initial cross-product axis). Ensure normalization. This should be vectorized across all clusters.
3.  **Vectorized Calculations:**
    *   Reshape `measurement_plane` to `measurement_points` (shape `(N_m, 3)`).
    *   Calculate the vector differences $\mathbf{R}_{ic} = \mathbf{r}_i - \mathbf{r}_c$ using broadcasting: `R_vec = measurement_points[:, None, :] - points[None, :, :]` (shape `(N_m, N_c, 3)`).
    *   Calculate distances $R_{ic} = |\mathbf{R}_{ic}|$: `R_dist = np.linalg.norm(R_vec, axis=2)` (shape `(N_m, N_c)`). Add a small epsilon for stability: `R_dist = np.maximum(R_dist, 1e-10)`.
    *   Calculate unit direction vectors $\hat{\mathbf{R}}_{ic} = \mathbf{R}_{ic} / R_{ic}$: `R_hat = R_vec / R_dist[:, :, None]` (shape `(N_m, N_c, 3)`).
    *   Calculate the scalar Green's function part: `G_scalar = np.exp(-1j * k * R_dist) / (4 * np.pi * R_dist)` (shape `(N_m, N_c)`).
4.  **Vectorized Projection Calculation:**
    *   Calculate dot products between $\hat{\mathbf{R}}_{ic}$ and tangent vectors $\hat{\mathbf{t}}_{c,1}, \hat{\mathbf{t}}_{c,2}$. Use `np.einsum` or broadcasting:
        *   `dot_R_t1 = np.einsum('ijk,jk->ij', R_hat, t_c1)` (shape `(N_m, N_c)`)
        *   `dot_R_t2 = np.einsum('ijk,jk->ij', R_hat, t_c2)` (shape `(N_m, N_c)`)
    *   Calculate the projected tangent vectors $(\mathbf{I} - \hat{\mathbf{R}}_{ic}\hat{\mathbf{R}}_{ic}) \cdot \hat{\mathbf{t}}_{c,k}$:
        *   `proj_t1 = t_c1[None, :, :] - R_hat * dot_R_t1[:, :, None]` (shape `(N_m, N_c, 3)`)
        *   `proj_t2 = t_c2[None, :, :] - R_hat * dot_R_t2[:, :, None]` (shape `(N_m, N_c, 3)`)
    *   Calculate the dot product with the measurement direction $\hat{\mathbf{u}}_{\text{meas}}$:
        *   `dot_meas_proj1 = np.einsum('k,ijk->ij', measurement_direction, proj_t1)` (shape `(N_m, N_c)`)
        *   `dot_meas_proj2 = np.einsum('k,ijk->ij', measurement_direction, proj_t2)` (shape `(N_m, N_c)`)
5.  **Construct Final Matrix H:**
    *   Initialize `H = np.zeros((N_m, 2 * N_c), dtype=np.complex128)`.
    *   Assign columns using slicing:
        *   `H[:, 0::2] = G_scalar * dot_meas_proj1`
        *   `H[:, 1::2] = G_scalar * dot_meas_proj2`
6.  **Final Touches:**
    *   Ensure the output matrix `H` is Fortran-contiguous using `np.asfortranarray(H)`.
    *   Return `H`.
