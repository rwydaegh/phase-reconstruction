import numpy as np
import pytest
from omegaconf import OmegaConf  # Using OmegaConf for config simulation

from src.create_test_pointcloud import create_test_pointcloud

# Import the new geometry utility function
from src.utils.geometry_utils import get_cube_normals

# Adjust the import path based on the file location within the project structure
from src.utils.preprocess_pointcloud import get_tangent_vectors


def test_get_tangent_vectors_generated_cube():
    """
    Tests the get_tangent_vectors function using inward-pointing normals derived
    from points generated by create_test_pointcloud for a non-perturbed cube.
    Checks for orthogonality between normals and tangents, and between tangents.
    """
    # Create a simple config for the test point cloud
    cfg_dict = {
        "room_size": 2.0,
        "wall_points": 5,  # Use a small number for faster testing
        "perturb_points": False,
        "verbose": False,  # Suppress print statements from create_test_pointcloud
    }
    cfg = OmegaConf.create(cfg_dict)

    # Generate initial cube points (including edges/corners)
    initial_points = create_test_pointcloud(cfg)
    assert initial_points.shape[0] > 0, "Test point cloud generation failed"

    # Get filtered points and their corresponding inward normals using the utility function
    points_on_face, normals_on_face = get_cube_normals(initial_points, cfg.room_size)

    assert (
        points_on_face.shape[0] > 0
    ), "No points found strictly on single faces by get_cube_normals"
    # Verification of normal calculation is implicitly done within get_cube_normals

    # Calculate tangents for the filtered normals
    t1, t2 = get_tangent_vectors(normals_on_face)

    # --- Assertions (on filtered data) ---
    # 1. Check shapes
    assert (
        t1.shape == normals_on_face.shape
    ), f"Expected t1 shape {normals_on_face.shape}, got {t1.shape}"
    assert (
        t2.shape == normals_on_face.shape
    ), f"Expected t2 shape {normals_on_face.shape}, got {t2.shape}"

    # 2. Check for NaN values
    assert not np.isnan(t1).any(), "Found NaN values in t1"
    assert not np.isnan(t2).any(), "Found NaN values in t2"

    # 3. Check normalization (vectors should be unit length)
    tolerance = 1e-6
    norm_t1 = np.linalg.norm(t1, axis=1)
    norm_t2 = np.linalg.norm(t2, axis=1)
    assert np.allclose(norm_t1, 1.0, atol=tolerance), f"t1 vectors are not normalized: {norm_t1}"
    assert np.allclose(norm_t2, 1.0, atol=tolerance), f"t2 vectors are not normalized: {norm_t2}"

    # 4. Check orthogonality using dot products (element-wise)
    dot_n_t1 = np.einsum("ij,ij->i", normals_on_face, t1)
    dot_n_t2 = np.einsum("ij,ij->i", normals_on_face, t2)
    dot_t1_t2 = np.einsum("ij,ij->i", t1, t2)

    ortho_tolerance = 1e-9
    assert np.all(
        np.abs(dot_n_t1) < ortho_tolerance
    ), f"Normals and t1 are not orthogonal: max dot product {np.max(np.abs(dot_n_t1))}"
    assert np.all(
        np.abs(dot_n_t2) < ortho_tolerance
    ), f"Normals and t2 are not orthogonal: max dot product {np.max(np.abs(dot_n_t2))}"
    assert np.all(
        np.abs(dot_t1_t2) < ortho_tolerance
    ), f"t1 and t2 are not orthogonal: max dot product {np.max(np.abs(dot_t1_t2))}"


def test_get_tangent_vectors_edge_cases():
    """Tests edge cases like zero normals or normals parallel to calculation axes."""
    # Normal parallel to initial axis ([0,0,1])
    normals_z = np.array([[0.0, 0.0, 1.0]])
    t1_z, t2_z = get_tangent_vectors(normals_z)
    assert np.allclose(np.abs(np.einsum("ij,ij->i", normals_z, t1_z)), 0.0)
    assert np.allclose(np.abs(np.einsum("ij,ij->i", normals_z, t2_z)), 0.0)
    assert np.allclose(np.abs(np.einsum("ij,ij->i", t1_z, t2_z)), 0.0)
    assert np.allclose(t1_z[0, 2], 0.0)  # Should lie in XY plane
    assert np.allclose(t2_z[0, 2], 0.0)  # Should lie in XY plane

    # Normal parallel to fallback axis ([1,0,0]) - relevant if initial axis was also [1,0,0]
    # Our current logic uses Z then X, so this case isn't strictly hit by the fallback,
    # but it's good to test axes alignment.
    normals_x = np.array([[1.0, 0.0, 0.0]])
    t1_x, t2_x = get_tangent_vectors(normals_x)
    assert np.allclose(np.abs(np.einsum("ij,ij->i", normals_x, t1_x)), 0.0)
    assert np.allclose(np.abs(np.einsum("ij,ij->i", normals_x, t2_x)), 0.0)
    assert np.allclose(np.abs(np.einsum("ij,ij->i", t1_x, t2_x)), 0.0)
    assert np.allclose(t1_x[0, 0], 0.0)  # Should lie in YZ plane
    assert np.allclose(t2_x[0, 0], 0.0)  # Should lie in YZ plane

    # Test with empty input
    normals_empty = np.empty((0, 3))
    t1_empty, t2_empty = get_tangent_vectors(normals_empty)
    assert t1_empty.shape == (0, 3)
    assert t2_empty.shape == (0, 3)

    # Note: The function currently warns and assigns defaults for zero vectors,
    # which isn't easily assertable without capturing warnings.
    # We rely on the orthogonality and normalization checks above.
